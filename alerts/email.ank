# Basic email alert module
# Example use:
# alert = emailAlert
# alert.EnableBatch()
# alert.SetServerPath(serverPath)
# alert.SetQueryParams(query, START.Add(-1*duration), START)
# alert.SetEmailParams(from, to, sub)
# alert.SetTitle(report_name)
# alert.ThrottleOn("ip", time.Hour)
# alert.ReingestAlerts("alerts", "testing", "SSH Login")
# alert.AddQueryLink(`extra info`, `tag=foo words bar`, START.Add(-1*duration), START)
# return alert.Run()
#
# Optional recipient lookup keying; when sending, rather than using the "to" address
# provided with SetEmailParams, will pull the "key" enumerated value from entries
# and use it to figure out recipients. If no match is in the map, the default is used.
# In batch mode, all recipients get a copy of the full email. In non-batch mode,
# each recipient receives his associated entry only.
# defaultEmail = "default@example.org"
# emailMap = { "foo": "foo@example.org", "bar": ["bar@example.org", "baz@example.org"] }
# alert.EnableRecipientLookup("key", defaultEmail, emailMap)
#
# Optional recipient lookup using an enumerated value, this option will look at the
# query results and use the value in an enumerated value to send the email
# alert.EnableEnumeratedEmailAddress("EmailField")

MinVer(3, 3, 1)

require("utils/reingest-json.ank", `2e2a8ef089bf77a42b73f761b1f55a7b69f7a1be`)
require("utils/throttle.ank", `2e2a8ef089bf77a42b73f761b1f55a7b69f7a1be`)
require("utils/links.ank", `2e2a8ef089bf77a42b73f761b1f55a7b69f7a1be`)
require("email/htmlEmail.ank", `2e2a8ef089bf77a42b73f761b1f55a7b69f7a1be`)

module emailAlert {
	var time = import("time")
	var serverBase = "http://localhost"
	var reingestTag = ""
	var reingestName = ""
	var reingestMsg = ""
	var batch = false
	var query  = ""
	var end = time.Now()
	var start = end.Add(-1*time.Hour)
	var body = ""
	var emailFrom = ""
	var emailTo = []
	var extraLinks = []
	var subject = ""
	var title = ""
	var subTitles = []
	
	var recipientLookupKey = ""
	var recipientMap = {}
	var defaultRecipient = ""

	var recipientKey = ""

	var enableThrottle = false
	var throttleEv = ""
	var throttleDur = 0
	var thr = throttle
	var ingestLinks = make(map[string]interface)

	func SetServerPath(p) {
		serverBase = p
	}

	func SetAlertEmailThrottleParam(evName, dur) {
		enableThrottle = true
		throttleEv = evName
		thr.SetMapName(evName)
		thr.SetInterval(dur)
	}

	func queryInfo() {
		var m = make(map[string]interface)
		m["Query"] = query
		m["Start"] = start
		m["End"] = end
		return m
	}

	func SetQueryParams(q, s, e) {
		query = q
		if e.Before(s) {
			start = e
			end = s
		} else {
			start = s
			end = e
		}
	}

	func SetEmailParams(frm, to, subj) {
		emailFrom = frm
		emailTo += to
		subject = subj
	}

	func EnableBatch() {
		batch = true
	}

	func SetTitle(v) {
		title=v
	}
	
	# syntax: EnableRecipientLookup(<ev key name>, <default recipient>, <map>)
	func EnableRecipientLookup(key, def, m) {
		recipientLookupKey = key
		recipientMap = m
		defaultRecipient = def
	}

	func EnableEnumeratedEmailAddress(evkey) {
		recipientKey = evkey
	}

	func queryLink(name, q, s, e) {
		var ln = link
		ln.Init(serverBase + "/#/search/launch")
		ln.AddParam("query", q)
		ln.AddParam("start", s.UTC().Format(time.RFC3339))
		if e != nil {
			ln.AddParam("end", e.UTC().Format(time.RFC3339))
		}
		if name == nil || len(name) == "" {
			name = `LINK`
		}
		return ln.HtmlEncode(name)
	}

	func AddQueryLink(name, q, s, e) {
		extraLinks += queryLink(name, q, s, e)
	}

	func ThrottleOn(evname, dur) {
		throttleEv = evname
		throttleDur = dur
		thr.SetInterval(dur)
	}

	func ReingestAlerts(tag, name, msg) {
		reingestTag = tag
		reingestName = name
		reingestMsg = msg
	}

	func reingestEnt(ent) {
		if reingestTag == "" {
			return nil
		}
		var re = reingest_json
		re.Init(reingestTag, reingestName)
		if reingestMsg != "" {
			re.SetHeaderValue("AlertMsg", reingestMsg)
		}
		var emailSent = !throttleEnt(ent)
		re.SetHeaderValue("EmailSent", emailSent)
		re.SetHeaderValue("AlertInfo", queryInfo())
		var t = time.Now()
		if emailSent {
			ev, err = getEntryEnum(ent, throttleEv)
			if err == nil {
				var id = re.IngestID()
				var lnk = re.AlertLink(serverBase, start, t, "Alert ID " + toString(id))
				ingestLinks[toString(ev)] = lnk
			}
		}
		return re.Ingest(ent, t)
	}

	func reingestEnts(ents) {
		for ent in ents {
			err = reingestEnt(ent)
			if err != nil {
				return err
			}
		}
		return nil
	}

	func getCols(ent) {
		var cols = []
		for ev in ent.Enumerated {
			cols += ev.Name
		}
		return cols
	}

	func markEnt(ent) {
		if throttleEv == "" {
			return nil
		}
		ev, err = getEntryEnum(ent, throttleEv)
		if err != nil {
			return err
		}

		thr.Mark(toString(ev), time.Now())
		return nil
	}

	func markEnts(ents) {
		for ent in ents {
			markEnt(ent)
		}
	}

	func throttleEnt(ent) {
		if throttleDur == 0 || throttleEv == "" {
			return false
		}
		ev, err = getEntryEnum(ent, throttleEv)
		if err != nil {
			#do not throttle on error
			return false
		}
		return thr.ShouldThrottle(toString(ev), nil)
	}

	func throttleEnts(ents) {
		if len(ents) == 0 {
			return nil
		}
		rents = ents[0:0]
		for ent in ents {
			if !throttleEnt(ent) {
				rents += ent
			}
		}
		return rents
	}

	func runBatch(ents, cols) {
		ents = throttleEnts(ents)
		if ents == nil || len(ents) == 0 {
			return
		}
		em = htmlEmail
		em.SetTitle(title)
		em.AddEntsTable(ents, cols)
		em.AddSubTitle("Query Links")
		#add core link
		em.AddBodyData(queryLink(`Alert Query`, query, start, end))
		for el in extraLinks {
			em.AddBodyData(el)
		}
		if len(ingestLinks) > 0 {
			em.AddSubTitle("Query Links")
			for k, v in ingestLinks {
				em.AddBodyData(v)
			}
		}
		var alertRecipients = emailTo
		if len(recipientLookupKey) > 0 {
			for e in ents {
				# they specified a lookup table for recipients
				var v, err = getEntryEnum(e, recipientLookupKey)
				if err != nil {
					# This is not great, but we will move on
					printf("Could not look up enumerated value %v: %v", recipientLookupKey, err)
					continue
				}
				r, ok = recipientMap[v]
				if !ok {
					// no recipient
					if len(defaultRecipient) > 0 {
						r = defaultRecipient
					} else {
						continue
					}
				}
				var found = false
				for existing in alertRecipients {
					if r == existing {
						found = true
						break
					}
				}
				if !found {
					alertRecipients += r
				}
			}
		}
		if len(recipientKey) > 0 {
			for e in ents {
				# they specified an EV for recipients
				var v, err = getEntryEnum(e, recipientKey)
				if err == nil {
					v = toString(v)
					var found = false
					for existing in alertRecipients {
						if v == existing {
							found = true
							break
						}
					}
					if !found {
						alertRecipients += v
					}
				}
			}
		}
		err = em.SendEmail(from, alertRecipients, subject)
		if err == nil && throttleDur > 0 {
			markEnts(ents)
		}
		return err
	}

	func runSingle(ent) {
		if throttleEnt(ent) {
			return nil
		}
		// This is a nasty hack we do because otherwise we end up with
		// a singleton htmlEmail and the body keeps growing...
		require("email/htmlEmail.ank", `2e2a8ef089bf77a42b73f761b1f55a7b69f7a1be`)
		em = htmlEmail
		em.SetTitle(title)
		em.AddEntTable(ent)
		em.AddSubTitle("Query Links")
		#add core link
		lnk = link
		lnk.Init(serverBase + "/#/search/launch")
		lnk.AddParam("query", query)
		lnk.AddParam("start", start.Format(time.RFC3339Nano))
		lnk.AddParam("end", end.Format(time.RFC3339Nano))
		em.AddBodyData(lnk.HtmlEncode("Alert Query"))
		for el in extraLinks {
			em.AddBodyData(el)
		}
		if len(ingestLinks) > 0 {
			ev, err = getEntryEnum(ent, throttleEv)
			if err == nil {
				lnk = ingestLinks[toString(ev)]
				if lnk != nil {
					em.AddSubTitle("Query Links")

				}
			}
		}
		var alertRecipients = emailTo
		if len(recipientLookupKey) > 0 {
			# they specified a lookup table for recipients
			var v, err = getEntryEnum(ent, recipientLookupKey)
			if err != nil {
				# This is... weird. Skip it.
				printf("Could not look up enumerated value %v: %v", recipientLookupKey, err)
			} else {
				r, ok = recipientMap[v]
				if !ok {
					// no recipient found, use the default
					if len(defaultRecipient) > 0 {
						r = defaultRecipient
					} else {
						// If no default set, don't send an email at all
						return nil
					}
				}
			}
			alertRecipients += r
		}
		if len(recipientKey) > 0 {
			var v, err = getEntryEnum(ent, recipientKey)
			if err == nil {
				v = toString(v)
				var found = false
				for existing in alertRecipients {
					if v == existing {
						found = true
						break
					}
				}
				if !found {
					alertRecipients += v
				}
			}
		}
		
		err = em.SendEmail(from, alertRecipients, subject)
		if err == nil && throttleDur > 0 {
			markEnt(ent)
		}
		return err
	}

	func Run() {
		ents, err = executeSearch(query, start, end)
		if err != nil {
			return err
		}
		if len(ents) == 0 {
			return nil
		}
		err = reingestEnts(ents)
		if err != nil {
			return err
		}

		if batch == true {
			return runBatch(ents, getCols(ents[0]))
		}

		//walk over each
		for ent in ents {
			err = runSingle(ent)
			if err != nil {
				return err
			}
		}
		return nil
	}
}
